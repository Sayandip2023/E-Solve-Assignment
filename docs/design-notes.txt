I designed the project as a complete machine learning system, not just a standalone predictive model. My main goal was to solve a real business problem: how to efficiently collect debts. This required two things: first, accurately predicting who won't repay, and second, turning that prediction into a clear, actionable plan for the collections team.

To start, I had to build a strong foundation. Since I didn't have access to real customer data, I decided to simulate a dataset of 1,000 customers myself. This gave me full control. Crucially, I intentionally built in a class imbalance, setting the repayment outcome at 80% Repaid versus 20% Not Repaid. I did this because I know that in the real world, the customers who actually default are a much smaller group, and my model needed to be trained in that challenging environment.

The next big step was preparing the data. I knew the models would perform better if all features were on the same scale, so I used the StandardScaler on everything numerical like Income and Credit Score. I also created some really important features. My goal was to move beyond the raw data, so I engineered things like the Debt-to-Income Ratio and, most importantly, a High-Risk Customer flag. This flag combined key business red flags (like having a low credit score and high days past due) into a single, powerful predictor.

When selecting models, I wanted a diverse lineup, but the class imbalance was my biggest hurdle. While I tested classic models like Logistic Regression and robust trees like XGBoost, I ultimately decided to use Random Under-Sampling on my training data. My thinking was that by balancing the classes this way, I could force the final model (often KNeighborsClassifier in the end) to focus intensely on the few "Not Repaying" examples, significantly boosting my Recall—which is vital for catching potential defaulters.

Finally, I focused on making the whole thing useful. I chose the F1-Score as my top evaluation metric because it gives me a good balance between catching defaulters and avoiding false alarms. I also added SHAP analysis so I could explain why the model made its decisions, which is essential for building trust with the business users. The entire system concludes with a Rule-Based Recommendation Engine. This engine takes the model's prediction and applies common-sense business logic—like prioritizing a customer with a Complaint Flag over one who is just slightly late—to generate the final best channel and strategy for contact.
